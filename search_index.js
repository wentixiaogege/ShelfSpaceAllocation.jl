var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide-1","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"This section explains how to install and get started with ShelfSpaceAllocation.jl.","category":"page"},{"location":"guide/#Installation-1","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"This package depends on Julia Language version 1.0.4, which can be downloaded from the download page. Make sure that Julia can be found in the path by typing julia in the terminal or command-line. Make sure that Julia can be found in the path by typing julia in the terminal. On Ubuntu, if Julia REPL doesn't open, add the Julia binaries to the path by appending export PATH=\"<path>/julia-1.0.4/bin:$PATH to .bashrc file located in the home directory. Replace <path> with the path where the binaries are located.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"ShelfSpaceAllocation.jl can be installed from GitHub using Julia's package manager","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"pkg> add https://github.com/jaantollander/ShelfSpaceAllocation.jl","category":"page"},{"location":"guide/#Solver-1","page":"Guide","title":"Solver","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"The shelf_space_allocation_model function returns the mathematical model which is implemented using JuMP.jl. It's up to the user to choose a suitable solver for solving the MILP model. For small instance GLPK is sufficient but for large instances, commercial solver such as Gurobi or CPLEX is recommended.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Gurobi is a powerful commercial optimizer which provides a free academic license. Gurobi can be interfaced with Julia using Gurobi.jl. Here are the steps to install Julia and Gurobi to run the program:","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Obtain a license of Gurobi and install Gurobi solver by following the instructions on Gurobi's website.\nMake sure the GUROBI_HOME environmental variable is set to the path of the Gurobi directory. This is part of standard installation. The Gurobi library will be searched for in GUROBI_HOME/lib on Unix platforms and GUROBI_HOME\\bin on Windows. If the library is not found, check that your version is listed in deps/build.jl. The environmental variable can be set by appending export GUROBI_HOME=\"<path>/gurobi811/linux64\" to .bashrc file. Replace the <path>, platform linux64 and version number 811 with the values of your Gurobi installation.\nInstall Gurobi.jl in Julia's package manager by running commands\npkg> add Gurobi\npkg> build Gurobi","category":"page"},{"location":"guide/#Examples-1","page":"Guide","title":"Examples","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Examples are located in the examples directory. Inside, the run.jl the file demonstrates how to run the optimization model on different example instances. There is also a Jupyter notebook version, examples/example.ipynb, of the file. Example instances can be found from the examples/instances directory. There are three instances in total, small, medium and large, named by their relative size. The computational complexity of solving the instances increases as the size increases.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"using CSV #hide\nusing Latexify #hide\ndf = CSV.read(joinpath(\"tables\", \"examples.csv\")) #hide\nmdtable(df,latex=false) #hide","category":"page"},{"location":"guide/#Documentation-1","page":"Guide","title":"Documentation","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"The project documentation is created using Documenter.jl. To build the documentation, navigate inside the docs directory and run the command","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"julia make.jl","category":"page"},{"location":"library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Documentation for ShelfSpaceAllocation.jl's interface.","category":"page"},{"location":"library/#Index-1","page":"Library","title":"Index","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Pages = [\"library.md\"]","category":"page"},{"location":"library/#Model-1","page":"Library","title":"Model","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"shelf_space_allocation_model","category":"page"},{"location":"library/#ShelfSpaceAllocation.shelf_space_allocation_model","page":"Library","title":"ShelfSpaceAllocation.shelf_space_allocation_model","text":"Mixed Integer Linear Program (MILP) formulation of the Shelf Space Allocation Problem (SSAP).\n\n\n\n\n\n","category":"function"},{"location":"library/#","page":"Library","title":"Library","text":"Sets and Subsets","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"pP – A set of products.\nsS – A set of shelves.\nbB – A set of blocks. Blocks are an index of mutually exclusive subsets of products.\nP_bP – A block is a subset of products.\nmM – A set of modules. Modules are an index of a mutually exclusive subset of shelves.\nS_mS – A module is a subset of shelves.","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"Parameters","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"N_p^min, N_p^max – The minimum and maximum number of facings for product p\nG_p – Unit profit of product p; used as shortage penalty (treated to be max0 G_p\nR_p – Replenishment period of product p\nD_p – Demand forecast of product p\nL_p – Priority weight for height placement of product p\nW_p – Facing width of product p\nH_p – Height of product p\nM_p – Unit weight of product p\nP_ps – Number units per facing of product p on shelf s\nM_s^min, M_s^max – The minimum and maximum unit weight on shelf s\nW_s – Width of shelf s\nH_s – Height of shelf s\nL_p – Shelf level, counted from bottom to top\nSL – Slack, maximum difference in block starting points and between block max and min width","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"Objective","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"min left(w_1 _s o_s + w_2 _p G_p e_p + w_3 _ps L_p L_s n_psright)","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"w_1=05\nw_2=100\nw_3=01","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"Basic Variables","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"n_ps – Number of facings of product p on shelf s\ns_p – Amount of product p sold\ne_p – Shortage of product p (mismatch between demand and on-shelf inventory)\no_p – Total empty space on shelf s\ny_p – 1 if product is assigned to module m, 0 otherwise","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"Basic Constraints","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"beginaligned\n n_ps  ℤ_0  ps \n y_p  01  p \n s_p  0  p \n e_p  0  p \n o_s  0  s \n \n n_ps=0  psH_p  H_s \n n_ps=0  psM_p  M_s^max \n _p n_ps  y_p  p \n N_p^min y_p  _s n_ps  N_p^max y_p  p \n s_p  minleft(_s frac30R_p P_ps n_ps D_pright)  p \n s_p + e_p = D_p  p \n _p W_p n_ps + o_s = W_s  s \nendaligned","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"Block Variables","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"z_bs – 1 if block is assigned on shelf s, otherwise 0\nz_bs^f – 1 if shelf s is the first shelf of block b, otherwise 0\nz_bs^l – 1 if shelf s is the last shelf of block b, otherwise 0\nb_bs – Width of block b on shelf s\nm_bm – Block width on module\nv_bm – 1 if block is assigned to module m, otherwise 0\nx_bs – Block starting location on shelf s\nx_bm – Block starting location on module m\nw_bb – 1 if block b precedes block b, otherwise 0","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"Block Constraints","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"beginaligned\n b_bs0  bs \n z_bs01  bs \n m_bm0  bm \n z_bs^f01  bs \n z_bs^l01  bs \n x_bs0  bs \n x_bm0  bm \n w_bb01  bb \n v_bm01  bm \n \n _pP_b W_p n_ps  b_bs  sb \n _b b_bs  W_s  s \n b_bs  W_s z_bs  bs \n b_bs  m_bm - W_s (1 - z_bs) - SL  bmssS_m \n b_bs  m_bm + W_s (1 - z_bs) + SL  bmssS_m \n \n _s z_bs^f  1  b \n _s z_bs^l  1  b \n z_bs^f = z_bs  bs=1 \n z_bs^l = z_bs  bs=S \n z_bs+1^f + z_bs = z_bs+1 + z_bs^l  bssS-1 \n \n _pP_b n_ps  z_bs  bs \n n_ps  N_p^max z_bs  bpspP_b \n \n x_bs  W_s z_bs  bs \n x_bs + b_bs  W_s  bs \n x_bs + W_s (1 - z_bs)  x_bs + b_bs - W_s (1 - w_bb)  bbmbb \n x_bs + W_s (1 - z_b s)  x_bs + b_bs - W_s w_bb  bbmbb \n x_bm  x_bs - W_s (1 - z_bs) - SL  bmssS_m \n x_bm  x_bs + W_s (1 - z_bs) + SL  bmssS_m \n \n n_ps  N_p^max v_bm  pbmssS_mpP_b \n _m v_bm  1  b\nendaligned","category":"page"},{"location":"library/#IO-1","page":"Library","title":"IO","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"load_parameters\nsave_results\nextract_variables\nextract_objectives","category":"page"},{"location":"library/#ShelfSpaceAllocation.load_parameters","page":"Library","title":"ShelfSpaceAllocation.load_parameters","text":"Load sets, subsets and parameters from CSV files.\n\n\n\n\n\n","category":"function"},{"location":"library/#ShelfSpaceAllocation.save_results","page":"Library","title":"ShelfSpaceAllocation.save_results","text":"Save parameters and variables into JSON file.\n\n\n\n\n\n","category":"function"},{"location":"library/#ShelfSpaceAllocation.extract_variables","page":"Library","title":"ShelfSpaceAllocation.extract_variables","text":"Extract optimized values from the model.\n\n\n\n\n\n","category":"function"},{"location":"library/#ShelfSpaceAllocation.extract_objectives","page":"Library","title":"ShelfSpaceAllocation.extract_objectives","text":"Extract objective values for individual objectives.\n\n\n\n\n\n","category":"function"},{"location":"library/#Plotting-1","page":"Library","title":"Plotting","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"planogram\nproduct_facings\nblock_allocation\ndemand_and_sales\nfill_amount\nfill_percentage","category":"page"},{"location":"library/#ShelfSpaceAllocation.planogram","page":"Library","title":"ShelfSpaceAllocation.planogram","text":"Creates a planogram which visualizes the product placement on the shelves.\n\n\n\n\n\nCreate a planogram for each module.\n\n\n\n\n\n","category":"function"},{"location":"library/#ShelfSpaceAllocation.product_facings","page":"Library","title":"ShelfSpaceAllocation.product_facings","text":"Creates a barchart of number of product facings per product.\n\n\n\n\n\n","category":"function"},{"location":"library/#ShelfSpaceAllocation.block_allocation","page":"Library","title":"ShelfSpaceAllocation.block_allocation","text":"Block starting locations and widths.\n\n\n\n\n\nCreate block_allocation for each module.\n\n\n\n\n\n","category":"function"},{"location":"library/#ShelfSpaceAllocation.demand_and_sales","page":"Library","title":"ShelfSpaceAllocation.demand_and_sales","text":"Bar chart of demand and sales per product.\n\n\n\n\n\n","category":"function"},{"location":"library/#ShelfSpaceAllocation.fill_amount","page":"Library","title":"ShelfSpaceAllocation.fill_amount","text":"Plot the total number of allocated facings per product per block.\n\n\n\n\n\n","category":"function"},{"location":"library/#ShelfSpaceAllocation.fill_percentage","page":"Library","title":"ShelfSpaceAllocation.fill_percentage","text":"Plot the percentage of allocated facings of maximum facings per block.\n\n\n\n\n\n","category":"function"},{"location":"heuristics/#Heuristics-1","page":"Heuristics","title":"Heuristics","text":"","category":"section"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"warning: Warning\nCurrently, heuristics are in an experimental state. Heuristics are tested only on a single instance. Therefore it cannot be guaranteed that they will obtain good results in all instances. Heuristics can be found at: examples/heuristics.jl","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Solving a mixed-integer linear program can be computationally difficult and integer programming is indeed NP-complete problem. Heuristics can be used to obtain feasible solutions and improving them faster than using deterministic algorithms by trading off some accuracy. Also, heuristics are not guaranteed to obtain good solutions. Two heuristics, relax-and-fix and fix-and-optimize, are covered here. In the literature, they are referred to as MIP-based heuristics, a type of metaheuristics. [Wolsey1998]","category":"page"},{"location":"heuristics/#Definitions-1","page":"Heuristics","title":"Definitions","text":"","category":"section"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Definitions in the context of linear programming heuristics.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Relaxation means removing integrality constraint from a variable.\nFixing variable means setting a fixed value for a variable.","category":"page"},{"location":"heuristics/#Relax-and-Fix-1","page":"Heuristics","title":"Relax-and-Fix","text":"","category":"section"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"The goal of relax-and-fix heuristic is to find reasonably good feasible solutions fast. These solutions can be later improved with the fix-and-optimize heuristic.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"The main design decision for relax-and-fix heuristic is choosing which variables will be relaxed. For shelf space allocation model the main options are the integer variables for number of facings n_ps and binary variables for block-shelf allocation z_bs, z_bs^f and z_bs^l. Testing indicated that relaxation of block-shelf allocation variables is a much better choice because the reduction to the computational time was much larger compared when using variables for number of facings.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Block-shelf allocation variables have two indices, blocks b and shelves s. The most logical choice is to partition the variables by the blocks. This is done by partitioning the set of blocks B into n disjoint subsets B_1 B_2  B_n. This also determines the order in which the variables are relaxed. Partitioning affects the runtime and goodness of the heuristic solution. The optimal way to partition is still unknown to us and partitioning policy is a user decision.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"example: Example\nFor example, B_1 could be partition to contain two blocks that are predicted to have most items allocated to the shelves, then partition B_2 to contain two blocks that are predicted to have second-most items allocated to the shelves and so forth.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Relax-and-fix heuristic. Start the iteration counter from i=1.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Relax. Solve the relaxed shelf space allocation model where","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"beginaligned\n z_bs z_bs^f z_bs^l01  bB_i s \n z_bs z_bs^f z_bs^l01  bB_i+1B_i+2B_n s\nendaligned","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Fix. Fix the variables z_bs z_bs^f z_bs^l for blocks bB_i and forall shelves s at their values.\nIf iteration counter is i=n return the solution. Otherwise, increment the iteration counter i by one and repeat from step 1.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"The block-shelf variables will be relaxed by a subset of blocks at a time. This transforms the original problem into one where all the blocks are not being allocated at the same time but one subset of blocks at a time.","category":"page"},{"location":"heuristics/#Fix-and-Optimize-1","page":"Heuristics","title":"Fix-and-Optimize","text":"","category":"section"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"The goal of fix-and-optimize heuristic is to improve the existing feasible solution, for example, one obtained from relax-and-fix heuristic. Fix-and-optimize heuristic operates by fixing a part of the variables to the values in the existing solution and making the other variables unfixed and then performing the optimization.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"For the shelf space allocation model, the block-shelf allocation variables were chosen as the target variables because they have the largest impact on the computational time. The simplest form of fix-and-optimize is to fix all of the target variables, which is used here. More intelligent strategies where only a part of the target variables are fixed could be beneficial for large instances, but this remains as a research question.","category":"page"},{"location":"heuristics/#Example-1","page":"Heuristics","title":"Example","text":"","category":"section"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"(Image: )","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"First, the shelf space allocation model is solved without the block constraints. It's very fast to solve and gives us a good starting point for setting the parameters for the heuristic.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"(Image: )","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Compute the absolute amount of products allocated on the shelves per block. Sort the blocks from most items allocated to least items allocated. Partition these indices into sets of chosen size. For example, in this case the sorted sequence of blocks is (7 1 2 6 4 8 9 3 5) and they are partitioned into four sets B_1=7 1, B_2=2 6, B_3=4 8 and B_4=9 3 5.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"This means that relax-and-fix heuristic will perform four iterations","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Next figures visualize which block allocation variables z_bs z_bs^f z_bs^l are fixed, binary and relaxed in each iteration.","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"(Image: )","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Relax-and-fix iteration 1:","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Fixed: b\nBinary: bB_1\nRelaxed: bB_2B_3B_4","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"(Image: )","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Relax-and-fix iteration 2:","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Fixed: bB_1\nBinary: bB_2\nRelaxed: bB_3B_4","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"(Image: )","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Relax-and-fix iteration 3:","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Fixed: bB_1B_2\nBinary: bB_3\nRelaxed: bB_4","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"(Image: )","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Relax-and-fix iteration 4:","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"Fixed: bB_1B_2B_3\nBinary: bB_4\nRelaxed: b","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"(Image: )","category":"page"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"The final solution is obtained by running the fix-and-optimize heuristic on the solution obtained by relax-and-fix. In this case, all block-shelf allocation variables z_bs z_bs^f z_bs^l and block-block relative order variables w_bb were fixed at their values.","category":"page"},{"location":"heuristics/#References-1","page":"Heuristics","title":"References","text":"","category":"section"},{"location":"heuristics/#","page":"Heuristics","title":"Heuristics","text":"[Wolsey1998]: Wolsey, L. A. (1998). Integer programming. Wiley.","category":"page"},{"location":"model/#Model-1","page":"Model","title":"Model","text":"","category":"section"},{"location":"model/#","page":"Model","title":"Model","text":"This section explains the mathematical formulation of the Mixed Integer Linear Program (MILP) for solving the Shelf Space Allocation Problem (SSAP). An introduction to the shelf space allocation problem is well covered by Maria Teresa in her Ph.D. thesis [Teresa2015]. Especially, chapters 1.3 and 3 are recommended reading as they relate to the model presented here. Modeling problems using mathematical programming including linear and integer programming are covered in [Williams2013].","category":"page"},{"location":"model/#Overview-1","page":"Model","title":"Overview","text":"","category":"section"},{"location":"model/#","page":"Model","title":"Model","text":"The objective of shelf space allocation model presented here is to minimize losses while taking into account consumer demand for products, minimize empty space on shelves and place products at preferred heights. The model is tailored towards smaller retail stores for which the shelf space accounts for a large portion of the total inventory space.","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The model also contains different types of constraints:","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Integrality constraints – The number of products allocated to each shelf must be integral.\nPhysical constraints – Constraints limiting the physical dimensions, e.g. width, height, and weight, of the products on the shelves.\nControl constraints – Constraints which can be controlled by changing parameters values, such as the minimum number of product facings for a particular product or the preferred height placement for a product.\nBlock constraints – Constraints products which belong to the same category to be placed together in rectangular shapes.","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The output values from the optimization are used to produce a planogram, which is a visualization of the product placement on to the shelves.","category":"page"},{"location":"model/#Sets-and-Subsets-1","page":"Model","title":"Sets and Subsets","text":"","category":"section"},{"location":"model/#","page":"Model","title":"Model","text":"Shelf space allocation problem consists of following sets and subsets:","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"pP – A set of products.\nsS – A set of shelves.\nbB – A set of blocks. Blocks are an index of mutually exclusive subsets of products.\nP_bP – A block is a subset of products.\nmM – A set of modules. Modules are an index of a mutually exclusive subset of shelves.\nS_mS – A module is a subset of shelves.","category":"page"},{"location":"model/#Parameters-1","page":"Model","title":"Parameters","text":"","category":"section"},{"location":"model/#","page":"Model","title":"Model","text":"Both products and shelves have several attributes associated with them. These attributes are also referred to as parameters since their values are given by the user. They are denoted using capital letters.","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"N_p^min, N_p^max – The minimum and maximum number of facings for product p\nG_p – Unit profit of product p; used as shortage penalty (treated to be max0 G_p\nR_p – Replenishment period of product p\nD_p – Demand forecast of product p\nL_p – Priority weight for height placement of product p\nW_p – Facing width of product p\nH_p – Height of product p\nM_p – Unit weight of product p\nP_ps – Number units per facing of product p on shelf s\nM_s^min, M_s^max – The minimum and maximum unit weight on shelf s\nW_s – Width of shelf s\nH_s – Height of shelf s\nL_p – Shelf level, counted from bottom to top\nSL – Slack, maximum difference in block starting points and between block max and min width","category":"page"},{"location":"model/#Objective-1","page":"Model","title":"Objective","text":"","category":"section"},{"location":"model/#","page":"Model","title":"Model","text":"note: Note\nCurrently, JuMP doesn't support multi-objective optimization, and thus the weights are manually tuned such that the algorithm obtains satisfying solutions. However, solvers such as Gurobi have capabilities for multi-objective optimization and using them should be considered in the future.","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The shelf space allocation model contains multiple objectives. The multi-objective formulation is reduced into single objective using linear scalarization, i.e. weighted sum","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"min _i=1^n w_i f_i","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"where f_i are the objectives and w_i0 are the weight parameters. There are n=3 different individual objectives defined as:","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"f_1=_s o_s – The total empty shelf space.\nf_2=_p G_p e_p – Total profit loss from product shortage.\nf_3=_ps L_p L_s n_ps – Product shelf height placement penalty. Preferres the placement of products with higher weight L_p to lower shelves.","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The weights corresponding to the objectives are named as:","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"w_1 – empty_space_penalty\nw_2 – shortage_penalty\nw_3 – shelf_up_down_penalty","category":"page"},{"location":"model/#Basic-Constraints-1","page":"Model","title":"Basic Constraints","text":"","category":"section"},{"location":"model/#","page":"Model","title":"Model","text":"(Image: )","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Number of facings of product p on shelf s","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"n_ps  ℤ_0 ps","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The height of product p allocated on shelf s must be less or equal to the shelf height","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"n_ps=0 psH_p  H_s","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The unit weight of product p allocated on shelf s must be less or equal to the maximum unit weight allowed on the shelf","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"n_ps=0 psM_p  M_s^max","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"A decision variable which takes value 1, if a product is allocated to a shelf, 0 otherwise","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"beginaligned\n y_p  01  p \n _p n_ps  y_p  p \nendaligned","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The total number of facings of product p must be within the given minimum and maximum","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"N_p^min y_p  _s n_ps  N_p^max y_p p","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The amount of product p sold must be less or equal to the minimum of the expected sales and demand","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"beginaligned\n s_p  0  p \n s_p  minleft(_s frac30R_p P_ps n_ps D_pright)  p\nendaligned","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"note: Note\nThe constraint of the form zmin(xy) can be linearized by replacing it with two constraints zx and zy.","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The shortage of product p is the mismatch between demand and on-shelf inventory","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"beginaligned\n e_p  0  p \n s_p + e_p = D_p  p\nendaligned","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Total empty space on shelf s is the difference between the width of the shelf s and the total width of the products on shelf s","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"beginaligned\n o_s  0  s \n _p W_p n_ps + o_s = W_s  s\nendaligned","category":"page"},{"location":"model/#Block-Constraints-1","page":"Model","title":"Block Constraints","text":"","category":"section"},{"location":"model/#","page":"Model","title":"Model","text":"(Image: )","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The width of block b on shelf s must be larger or equal to the sum of the widths of products P_b on the shelf s","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"beginaligned\n b_bs0 bs \n _pP_b W_p n_ps  b_bs sb \nendaligned","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"The sum of the block widths on each shelf s must be less or equal to the width of the shelf s","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"_b b_bs  W_s s","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"An indicator variable which takes value 1 if block is assigned on a shelf s, 0 otherwise","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"beginaligned\n z_bs01 bs \n b_bs  W_s z_bs bs\nendaligned","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"note: Note\nIndicator variable σ is a binary variable which is forced to take value 1 when x0, otherwise 0, by the constraint xMσ where M is a constant coefficient representing a known upper bound for x.","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Block width on module m","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"beginaligned\n m_bm0  bm \n b_bs  m_bm - W_s (1 - z_bs) - SL  bmssS_m \n b_bs  m_bm + W_s (1 - z_bs) + SL  bmssS_m\nendaligned","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"A decision variable which takes value 1 if shelf s is the first shelf of a block b, 0 otherwise","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"z_bs^f01 bs","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"A decision variable which takes value 1 if shelf s is the last shelf of a block b, 0 otherwise","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"z_bs^l01 bs","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Each block b has only one first shelf","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"_s z_bs^f  1 b","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Each block b has only one last shelf","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"_s z_bs^l  1 b","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Block assignment z_bs of block b is continuous from the first shelf to the last shelf of the block","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"beginaligned\n z_bs^f = z_bs  bs=1 \n z_bs^l = z_bs  bs=S \n z_bs+1^f + z_bs = z_bs+1 + z_bs^l  bssS-1\nendaligned","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"If block b is assigned on shelf s then the total number of facings assigned to shelf s must be at least one","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"_pP_b n_ps  z_bs bs","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"If block b is not assignment on shelf s then the number of facings of products in P_b on shelf s must be zero.","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"n_ps  N_p^max z_bs bpspP_b","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Block starting location (in mm) on shelf s","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"x_bs0 bs","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Block starting location is zero if block b is not assigned on shelf s","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"x_bs  W_s z_bs bs","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Block ending location must not exceed the shelf width","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"x_bs + b_bs  W_s bs","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"A decision variable which takes value 1 if block b precedes block b, 0 otherwise. Notice that b and b are mutually exclusive, i.e. bb","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"beginaligned\n w_bb01  bb \n x_bs + W_s (1 - z_bs)  x_bs + b_bs - W_s (1 - w_bb)  bbmbb \n x_bs + W_s (1 - z_b s)  x_bs + b_bs - W_s w_bb  bbmbb\nendaligned","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Block starting location on module m","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"beginaligned\n x_bm0  bm \n x_bm  x_bs - W_s (1 - z_bs) - SL  bmssS_m \n x_bm  x_bs + W_s (1 - z_bs) + SL  bmssS_m\nendaligned","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"An indicator variable which takes value 1 if a block is assigned on a module, 0 otherwise","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"v_bm01 bm","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"If a block is not assigned module there must be zero facings of the product belonging to the block on the shelves belonging to the module","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"n_ps  N_p^max v_bm pbmssS_mpP_b","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"Block b is assigned to only one module m","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"_m v_bm  1 b","category":"page"},{"location":"model/#References-1","page":"Model","title":"References","text":"","category":"section"},{"location":"model/#","page":"Model","title":"Model","text":"[Teresa2015]: Teresa, M. (2015). The Retail Shelf Space Allocation Problem: New Optimization Methods Applied to a Supermarket Chain.","category":"page"},{"location":"model/#","page":"Model","title":"Model","text":"[Williams2013]: Williams, H. P. (2013). Model building in mathematical programming. John Wiley & Sons.","category":"page"},{"location":"visualization/#Visualization-1","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"This section illustrates the results of the optimization model using visualizations implemented with Plots.jl.","category":"page"},{"location":"visualization/#Planogram-1","page":"Visualization","title":"Planogram","text":"","category":"section"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"Planogram visualizes the product placing on the shelves. Blocks are indicated by the different colors. A definition of planogram can be found at [Rouse2010].","category":"page"},{"location":"visualization/#Block-Allocation-1","page":"Visualization","title":"Block Allocation","text":"","category":"section"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"Block allocation visualizes the block starting location x_bs and block width b_bs for each block and for each shelf.","category":"page"},{"location":"visualization/#Product-Facings-1","page":"Visualization","title":"Product Facings","text":"","category":"section"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"Visualizes the number of product facings _s n_ps allocated per product. The opaque color indicates the maximum number of facings N_p^max allowed per product.","category":"page"},{"location":"visualization/#Demand-and-Sales-1","page":"Visualization","title":"Demand and Sales","text":"","category":"section"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"Visualizes the sales s_p per product. The opaque color indicates the demand D_p per product.","category":"page"},{"location":"visualization/#Fill-Amount-1","page":"Visualization","title":"Fill Amount","text":"","category":"section"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"Fill amount visualizes the total amount of products facings _pP_bsS n_ps allocated to the shelves per block.","category":"page"},{"location":"visualization/#Fill-Percentage-1","page":"Visualization","title":"Fill Percentage","text":"","category":"section"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"Fill percentage visualizes the relative amount of product facings allocated to the shelves per block. Calculated by dividing the absolute amount of product facing allocated per block by the number of products that could be allocated to the shelves per block if there were no products from other blocks.","category":"page"},{"location":"visualization/#References-1","page":"Visualization","title":"References","text":"","category":"section"},{"location":"visualization/#","page":"Visualization","title":"Visualization","text":"[Rouse2010]: Rouse, M. (2010). What is planogram? Retrieved from https://whatis.techtarget.com/definition/planogram","category":"page"},{"location":"#ShelfSpaceAllocation.jl-1","page":"Home","title":"ShelfSpaceAllocation.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package contains an optimization model for solving the shelf space allocation problem (SSAP) in the context of retail stores, formulated as mixed-integer linear program (MILP). The package is intended for both, developing and running the model. It includes the model, visualization capabilities, input/output related functions, and example instances. The documentation covers how to use the package, its functionalities and the model in detail.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package is a part of a research project at the Systems Analysis Laboratory at Aalto University, authored by Fabricio Oliveira and Jaan Tollander de Balsch.","category":"page"},{"location":"io/#IO-1","page":"IO","title":"IO","text":"","category":"section"},{"location":"io/#","page":"IO","title":"IO","text":"For input and output of numerical values, simple plain text formats CSV and JSON are used. CSV is used for representing tabular data and JSON is used for representing non-tabular, dictionary-like, data.","category":"page"},{"location":"io/#Parameters-1","page":"IO","title":"Parameters","text":"","category":"section"},{"location":"io/#","page":"IO","title":"IO","text":"Input parameters for products and shelves are given in tabular format as CSV files, products.csv and shelves.csv.","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"Each products.csv file contains following attributes:","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"product_id\ncategory_id\nbrand_id\nwidth\nheight\ndepth\nweight\nmonthly_demand\nreplenishment_interval\nprice\nunit_margin\nblocking_field\nmin_facing\nmax_facing\nmax_stack\nup_down_order_criteria","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"Each shelves.csv file contains following attributes:","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"module\nid\nlevel\ntotal_width\ntotal_height\ntotal_length\nproduct_min_unit_weight\nproduct_max_unit_weight","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"Examples of input parameters can found inside examples/instances directory.","category":"page"},{"location":"io/#Results-1","page":"IO","title":"Results","text":"","category":"section"},{"location":"io/#","page":"IO","title":"IO","text":"Results are best stored in a non-tabular format as JSON files.","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"note: Note\nWhen certain Julia data types are written and then read from JSON they don't retain their Julia specific data type. For example, 2-dimensional arrays will be stored as nested arrays. Where the elements of the original 2-dimensional are accessed using indices z_bs[b, s], the same elements of the nested array read from the JSON file are accessed using indices z_bs[s][b].","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"Variables are stored in variables.json file such that variables names, as they are written in the code, are used as keys and the values are queried from solution.","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"Parameters are stored in parameters.json file using the parameter names, as they are written in the code, are used as keys and the values as they were loaded using load_parameters function.","category":"page"},{"location":"io/#","page":"IO","title":"IO","text":"Individual objective values are written into objectives.json file.","category":"page"}]
}
